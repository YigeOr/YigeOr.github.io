<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[杂记-071010]]></title>
      <url>%2F2017%2F10%2F10%2Fessay-071010%2F</url>
      <content type="text"><![CDATA[2017年10月10日突然发现图片都挂了，懒得弄了~ 相见时难别亦难，东风无力百花残。 欢迎转载，转载请注明出处，谢谢！本文链接：http://zhaoyunkang.com/2017/10/10/essay-071010/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java网络编程(Socket)]]></title>
      <url>%2F2017%2F03%2F21%2Fjava-socket%2F</url>
      <content type="text"><![CDATA[一、网络编程的主要问题： 如何准确的定位网络上一台或者多台主机 找到主机后如何可靠高效的传输数据 二、TCP（ Tranfer Control Protocol传输控制协议） 是面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达)传输层协议 通过TCP协议传输，得到的是一个顺序的无差错的数据流 传输效率较UDP低 是面向连接的，有比较高的可靠性 三、UDP（User Datagram Protocol用户数据报协议） 是一个简单的面向数据报的运输层协议 不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地 传输效率高 发送方所发送的数据报并不一定以相同的次序到达接收方 四、SocketSocket可以说是一种针对网络的抽象，应用通过它可以来针对网络读写数据。根据TCP协议和UDP协议的不同，在网络编程方面就有面向两个协议的不同socket，一个是面向字节流的一个是面向报文的。网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket。Socket通常用来实现客户方和服务方的连接。 一个Socket由一个IP地址和一个端口号唯一确定。 五、Socket服务端 构建一个ServerSocket实例，指定本地的端口。这个socket就是用来监听指定端口的连接请求的。 如：ServerSocket server = new ServerSocket(8080); 创建Socket并调用ServerSocket 的accept()方法来获得客户端的连接请求。通过accept()方法返回的socket实例，建立了一个和客户端的新连接。 通过这个返回的socket实例获取InputStream和OutputStream,可以通过这两个流来分别读和写数据。 调用Socket 实例的close()方法，关闭Socket。 代码示例： import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.ServerSocket; import java.net.Socket; /** * @author Yige * @create 2017-02-22 15:09 */ public class ServerSocketCToS { public static void main(String[] args) { try { ServerSocket serverSocket = new ServerSocket(8080); Socket socket = serverSocket.accept(); // BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); boolean flag = true; while (flag){ String enter = reader.readLine(); System.out.println(&quot;客户端：&quot; + enter); if (&quot;233&quot;.equals(enter)){ System.out.println(&quot;结束会话！&quot;); flag = false; } } reader.close(); socket.close(); serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } 六、Socket客户端 构建Socket实例 通过指定的远程服务器地址和端口来建立连接。如：Socket socket = new Socket(&quot;localhost&quot;, 8080); 通过Socket实例包含的InputStream和OutputStream来进行数据的读写。 调用Socket实例的close方法，关闭Socket。 代码示例： import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.Socket; /** * @author Yige * @create 2017-02-22 15:09 */ public class ClientSocketCToS { public static void main(String[] args) { try { Socket socket = new Socket(&quot;127.0.0.1&quot;,8080); BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); PrintWriter printWriter = new PrintWriter(socket.getOutputStream(), true); String enter = in.readLine(); while (!&quot;233&quot;.equals(enter)){ printWriter.println(enter); System.out.println(&quot;我(客户端)：&quot; + enter); enter = in.readLine(); } printWriter.close(); socket.close(); } catch (IOException e) { e.printStackTrace(); } } } 上边的源码是一对一的！以后可以用多线程实现一个服务器对多个客户端！ PS：一些题外话：Socket编程好早就接触过了，然后就是照着书上把代码敲出来，过后就忘了。借着偶然看见的一些资料，在这里重新复习下。 学无止境，为我兔的星辰大海！ 一些参考文档：http://www.cnblogs.com/linzheng/archive/2011/01/23/1942328.htmlhttp://www.cnblogs.com/elgin-seth/p/5293713.htmlhttps://zhidao.baidu.com…… 欢迎转载，转载请注明出处，谢谢！本文链接：http://zhaoyunkang.com/2017/03/21/java-socket/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手动触发动态加载的一二级下拉框(select)的change属性]]></title>
      <url>%2F2017%2F03%2F13%2Fjq-select-change%2F</url>
      <content type="text"><![CDATA[前言由于项目需要，所以需要搞一个动态加载的下拉框的默认选定功能，下拉框总共有两级。 实现首先通过ajax同步获取下拉框信息： $.ajax({ async: false, type: &quot;GET&quot;, url: &quot;../../message/*******&quot;, dataType: &quot;json&quot;, error: function () { alert(&apos;请求失败&apos;); }, success: function (data) { for (var i = 0; i &lt; data.length; i++) { $(&quot;#categoryOne&quot;).append(&quot;&lt;option value=&apos;&quot; + data[i].cId + &quot;&apos; &gt;&quot; + data[i].cCategoryName + &quot;&lt;/option&gt;&quot;); } } }); 然后设置一级下拉框属性： $(&apos;#categoryOne&apos;).val(&apos;${articleInfo.cOneCategoryId}&apos;); 再就是设置一级下拉框的change属性： $(&quot;#categoryOne&quot;).change(function () { var parentId = $(&quot;#categoryOne&quot;).val(); if (parentId == 0) { parentId = -1; } $.ajax({ async: false, type: &quot;GET&quot;, url: &quot;../../message/*******&quot;, data: &quot;parentId=&quot;+parentId, dataType: &quot;json&quot;, error: function () { alert(&apos;请求失败&apos;); }, success: function (data) { $(&quot;#categoryTwo&quot;).html(&apos;&lt;option value=&quot;-1&quot;&gt;二级类目&lt;/option&gt;&apos;); for (var i = 0; i &lt; data.length; i++) { $(&quot;#categoryTwo&quot;).append(&quot;&lt;option value=&apos;&quot; + data[i].cId + &quot;&apos; &gt;&quot; + data[i].cCategoryName + &quot;&lt;/option&gt;&quot;); } } }); }); 然后就是触发一级下拉框的change属性： $(&quot;#categoryOne&quot;).trigger(&apos;change&apos;); 最后就是设置二级下拉框属性： $(&apos;#categoryTwo&apos;).val(&apos;${articleInfo.cTwoCategoryId}&apos;); 下边是一二级下拉框的定义： &lt;tr&gt; &lt;td style=&quot;text-align: right;font-weight: bold;color: #369;&quot;&gt;一级类目&lt;font color=&quot;red&quot;&gt;*&lt;/font&gt;：&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;categoryOne&quot; id=&quot;categoryOne&quot; style=&quot;width: 100px;&quot;&gt; &lt;option value=&quot;&quot;&gt;一级类目&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;td style=&quot;text-align: right;font-weight: bold;color: #369;&quot;&gt;二级类目&lt;font color=&quot;red&quot;&gt;*&lt;/font&gt;：&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;categoryTwo&quot; id=&quot;categoryTwo&quot; style=&quot;width: 100px;&quot;&gt; &lt;option value=&quot;&quot;&gt;二级类目&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; 需要注意的地方要使$(&quot;#categoryOne&quot;).trigger(&#39;change&#39;);这个命令有作用就先得把一级下拉框的change定义了。我在网上查了好多资料，好像没有说要注意这点的。或许这个对于前端开发来说是常识吧，还是写接口快，网页搞起来微麻烦！XDDD 欢迎转载，转载请注明出处，谢谢！本文链接：http://zhaoyunkang.com/2017/03/13/jq-select-change/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我和谁都不争]]></title>
      <url>%2F2017%2F03%2F06%2Fstrove-with-none%2F</url>
      <content type="text"><![CDATA[我和谁都不争，和谁争我都不屑；我爱大自然，其次就是艺术；我双手烤着生命之火取暖；火萎了，我也准备走了。 -兰德（英） 杨绛（译）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在github上安装Hexo过程中遇到的坑]]></title>
      <url>%2F2017%2F03%2F03%2Fhexo-pit%2F</url>
      <content type="text"><![CDATA[概要趁着还没忘干净，首先先说一下，创建github上的代码仓库开始，到现在的安装过程和遇到的各种坑。 代码上传不到github像我上一篇讲到的那个，下载好hexo和nodejs后没有配置相应的ssh公钥，所以init初始化的时候用的是我以前的配置文件（以前在电脑上搞过github），所以配置文件不对导致上传不上去，最后配置好ssh文件并保存到自己github上之后再初始化就可以上传静态page了。 用hexo g命令报错我用的是NexT.Mist主题，照着Next主题配置网站 配置主题后发现加载主题报错，然后就开始纠结了。出错提示： FATAL (unknown path) [Line 7, Column 23] Error: Unable to call `the return value of (posts[&quot;first&quot;])[&quot;updated&quot;][&quot;toISOString&quot;]`, which is undefined or falsey Template render error: (unknown path) [Line 7, Column 23] Error: Unable to call `the return value of (posts[&quot;first&quot;])[&quot;updated&quot;][&quot;toISOString&quot;]`, which is undefined or falsey at Object.exports.prettifyError (E:\test\blog\node_modules\nunjucks\src\lib.js:34:15) at E:\test\blog\node_modules\nunjucks\src\environment.js:486:31 at new_cls.root [as rootRenderFunc] (eval at _compile (E:\test\blog\node_modules\nunjucks\src\environment.js:565:24), &lt;anonymous&gt;:161:3) at new_cls.render (E:\test\blog\node_modules\nunjucks\src\environment.js:479:15) at Hexo.module.exports (E:\test\blog\node_modules\hexo-generator-feed\lib\generator.js:28:22) 由于刚开始是习惯性的从后边往前找错误，看见这个发现没见过这个错误，就开始各种baidu、google搞了一会，发现网上的方法都不行呢，然后就回来重新从头看错误，就发现刚开始开头的这个错误： TypeError: Cannot read property &apos;offset&apos; of null at Object.exports.timezone (E:\test\blog\node_modules\hexo\lib\plugins\processor\common.js:44:40) at E:\test\blog\node_modules\hexo\lib\plugins\processor\post.js:83:42 at tryCatcher (E:\test\blog\node_modules\bluebird\js\release\util.js:16:23) at Promise._settlePromiseFromHandler (E:\test\blog\node_modules\bluebird\js\release\promise.js:507:35) at Promise._settlePromise (E:\test\blog\node_modules\bluebird\js\release\promise.js:567:18) …… 去检查配置的时候发现了由于我刚刚在进行主题配置的时候顺手就把站点配置里边的时区配置给改了。原来是这个样子timezone: Asia/Shanghai我给顺手改成了timezone: Asia/Beijing话说咱们不是东八区吗。:-D 改回上海就好了！ 配置域名我的域名是在狗爹上买的。首先去github上配置CNAME，也就是设置里的Custom domain如下图：然后在网上找了下资料，发现需要得到github的ip地址（由于我的github用户名是：yigeor，所以在本机ping yigeor.github.io得到域名），然后配置到域名解析里边。然后。。。然后访问zhaoyunkang.com访问不到，访问yigeor.github.io也不行了，有句mmp讲了N遍。试过用CNAME配置@和www直接指向yigeor.github.io不行，用A直配置@和www指向yigeor.github.io不行，用CNAME和A直接指向ip也不行，直接在域管理里边转到yigeor.github.io还是不行。最后折腾来折腾去，发现还是域名解析的问题。狗爹的默认域名服务器是国外的，然后我弄了个代理，设置全局模式，发现可以解析了（配置：A配置的@和www直接指向ip）。。这个不设置代理就访问不到有点坑了，然后就改了域名服务器，改到了DNSPOD上，域名服务器配置如下： 域名服务器 a.dnspod.com b.dnspod.com c.dnspod.com 评论插件刚开始用的是多说，然后发现多说上面问题挺多的，我自己就发现好多次评论插件加载不出来。后来用的是DISQUS，但是这个对于不会搭梯子的人也还有个很大的缺陷，就是在国内好多地方被墙了。。。但是我还是选择了这个。可以邮件提醒有人评论了自己的什么文章，多说应该也行。最后，还是用多说吧 (⊙﹏⊙)b 搜索功能试了一下Swiftype最后发现自带的搜索Local Search也挺给力的，果断换之。 统计百度统计和谷歌统计都加了，百度统计好加，谷歌统计就有点尴尬了，这是官网配置截图：我复制的时候是从UA-后边复制的，格式是XXXXXXXX-X，发现好像根本就不能统计到，然后再试XXXXXXXX，还是不行，搞的都想放弃谷歌统计了，突然想到把UA加上，最后把UA加在前边，格式为UA-XXXXXXXX-X。然后就好了，哈哈 可能还是我自己理解能力有问题。【认真脸】 问题还有个问题暂时还没找见解决办法。。。谁告诉我这个图标怎么换： 补充上边这个问题解决了，偶然看见配置文件里的一行代码，制作一个文件favicon.ico就好了，配置如下： # Put your favicon.ico into `hexo-site/source/` directory. favicon: /favicon.ico 暂时能想到的就是这些，如果有什么不对的地方，欢迎大家相互交流，相互学习！！ 欢迎转载，转载请注明出处，谢谢！本文链接：http://zhaoyunkang.com/2017/03/03/hexo-pit/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HelloWorld]]></title>
      <url>%2F2017%2F02%2F23%2FpostName%2F</url>
      <content type="text"><![CDATA[经过今天几个小时的研究，我的这个小站也算是可以正常访问了（捂脸笑）。其实刚开始的时候进行的挺顺利的，就是在hexo往github上部署的时候出了点问题。我是在网上搜索的教程来进行这个小站的创建的，但是并没有严格按照教程上说的先配置ssh密钥，而是把这一步跳过，先各种配置hexo然后在init hexo，这样做的结果就是静态页面上不到github上面去，最后在各种找答案无果的情况下，把刚才init相关的git配置都删除了，然后配置密钥后再链接，然后成功了，无奈，浪费好多时间。这个先是记录一下。然后再去弄点好的主题。 哈哈先这样吧！！]]></content>
    </entry>

    
  
  
</search>
